#     Copyright (C) 2024 LaiTeP and contributors
#
#     This file is part of the sage_libgap distribution.
#
#     The sage_libgap package is free software; you can redistribute it and/or
#     modify it under the terms of the GNU General Public License as published
#     by the Free Software Foundation, either version 3 of the License, or (at
#     your option) any later version.
#
#     The sage_libgap package is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
#     Public License for more details.
#
#     You should have received a copy of the GNU General Public License along
#     with sage_libgap package. If not, see <https://www.gnu.org/licenses/>.
#


import argparse
import os
import pathlib
import shutil
from typing import List

AUTOGEN_TEXT_PY = (
    "###############################################################################\n"
    "# This file was automatically generated by extract_sage_libgap.py. DO NOT EDIT!\n"
    "###############################################################################\n"
    "#\n"
    "#     Copyright (C) 2024 LaiTeP and contributors\n"
    "#\n"
    "#     This file is part of the sage_libgap distribution.\n"
    '#     It is an automatically modified version of a file in the "Sage: a free\n'
    '#     open-source mathematics software system" software package. Further\n'
    "#     licensing information may be available further down this file.\n"
    "#\n"
    "#     The sage_libgap package is free software; you can redistribute it and/or\n"
    "#     modify it under the terms of the GNU General Public License as published\n"
    "#     by the Free Software Foundation, either version 3 of the License, or (at\n"
    "#     your option) any later version.\n"
    "#\n"
    "#     The sage_libgap package is distributed in the hope that it will be useful,\n"
    "#     but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
    "#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General\n"
    "#     Public License for more details.\n"
    "#\n"
    "#     You should have received a copy of the GNU General Public License along\n"
    "#     with sage_libgap package. If not, see <https://www.gnu.org/licenses/>.\n"
    "#\n"
    "###############################################################################\n"
    "\n"
)

AUTOGEN_TEXT_C = (
    "/******************************************************************************\n"
    "# This file was automatically generated by extract_sage_libgap.py. DO NOT EDIT!\n"
    "*******************************************************************************\n"
    "#\n"
    "#     Copyright (C) 2024 LaiTeP and contributors\n"
    "#\n"
    "#     This file is part of the sage_libgap distribution.\n"
    '#     It is an automatically modified version of a file in the "Sage: a free\n'
    '#     open-source mathematics software system" software package. Further\n'
    "#     licensing information may be available further down this file.\n"
    "#\n"
    "#     The sage_libgap package is free software; you can redistribute it and/or\n"
    "#     modify it under the terms of the GNU General Public License as published\n"
    "#     by the Free Software Foundation, either version 3 of the License, or (at\n"
    "#     your option) any later version.\n"
    "#\n"
    "#     The sage_libgap package is distributed in the hope that it will be useful,\n"
    "#     but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
    "#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General\n"
    "#     Public License for more details.\n"
    "#\n"
    "#     You should have received a copy of the GNU General Public License along\n"
    "#     with sage_libgap package. If not, see <https://www.gnu.org/licenses/>.\n"
    "#\n"
    "******************************************************************************/\n"
    "\n"
)

SAGE_FILES_TO_COPY = {
    os.sep.join(["src", "sage", "arith", "long.pxd"]): "arith",
    os.sep.join(["src", "sage", "cpython", "builtin_types.pyx"]): "cpython",
    os.sep.join(["src", "sage", "cpython", "getattr.pxd"]): "cpython",
    os.sep.join(["src", "sage", "cpython", "getattr.pyx"]): "cpython",
    os.sep.join(["src", "sage", "cpython", "pycore_long.h"]): "cpython",
    os.sep.join(["src", "sage", "cpython", "pycore_long.pxd"]): "cpython",
    os.sep.join(["src", "sage", "cpython", "string.pxd"]): "cpython",
    os.sep.join(["src", "sage", "cpython", "string.pyx"]): "cpython",
    os.sep.join(["src", "sage", "cpython", "string_impl.h"]): "cpython",
    os.sep.join(["src", "sage", "cpython", "wrapperdescr.pxd"]): "cpython",
    os.sep.join(["src", "sage", "cpython", "wrapperdescr.pyx"]): "cpython",
    os.sep.join(["src", "sage", "interfaces", "gap_workspace.py"]): "interfaces",
    os.sep.join(["src", "sage", "libs", "gmp"]): os.sep.join(["libs", "gmp"]),
    os.sep.join(["src", "sage", "misc", "persist.pyx"]): "misc",
    os.sep.join(["src", "sage", "misc", "temporary_file.py"]): "misc",
    os.sep.join(["src", "sage", "rings", "integer_fake.h"]): "rings",
    os.sep.join(["src", "sage", "rings", "integer_fake.pxd"]): "rings",
    os.sep.join(["src", "sage", "structure", "richcmp.pxd"]): "structure",
    os.sep.join(["src", "sage", "structure", "richcmp.pyx"]): "structure",
}

# Patches are applied after namespace fixing, so factor this into account
PATCHES = {
    "element.pxd": {
        "cimport Element, ModuleElement, RingElement": "cimport Element",
        "cdef class GapElement(RingElement):": "cdef class GapElement(Element):",
    },
    "element.pyx": {
        "from sage_libgap.libgap import libgap\n": "",
        "from sage.groups.perm_gps.permgroup_element cimport PermutationGroupElement\n": "",
        "from sage.combinat.permutation import Permutation\n": "",
        "from sage_libgap.structure.coerce cimport coercion_model as cm\n": "",
        "    GAP_IN = libgap.eval(r'\in')": "    from sage_libgap.libgap import libgap; GAP_IN = libgap.eval(r'\in')",
        "cdef class GapElement(RingElement):": "cdef class GapElement(Element):",
        "# Add support for _instancedoc_\n": "",
        "from sage_libgap.misc.instancedoc import instancedoc\n": "",
        "instancedoc(GapElement_Function)\n": "",
        "instancedoc(GapElement_MethodProxy)\n": "",
    },
    "libgap.pyx": {
        "from sage_libgap.structure.parent cimport Parent\n": "",
        "from sage_libgap.structure.element cimport Vector\n": "",
        "from sage.rings.integer_ring import ZZ\n": "",
        "randstate cimport current_randstate": "randstate import current_randstate",
        "class Gap(Parent):": "class Gap:",
        "def _element_constructor_(self, x):": "def __call__(self, x):",
        ", Vector": "",
        "Parent.__init__(self, base=ZZ)": "pass",
    },
    "pycore_long.h": {
        # This is a bug in Sage that makes compilation fail in Python 3.8
        "Py_SIZE(o) = size;": "Py_SIZE(op) = size;"
    },
    "util.pyx": {"from sage_libgap.element cimport *\n": ""},
}

FUNCTIONS_TO_REMOVE = {
    "element.pyx": [
        ["GapElement", "sage"],
        ["GapElement_Permutation", "sage"],
    ]
}

MISSING_LIBGAP_IMPORT = {
    "element.pyx": [
        "Obj make_gap_list",
        "Obj make_gap_matrix",
        "Obj make_gap_record",
        "_from_sage",
    ]
}


def get_indentation_level(string: str) -> int:
    """Returns the identation level of a string.

    :param string: Line of code
    :type string: str
    """
    level = 0
    while string[level] == " ":
        level += 1
    return level


def remove_function_implementation(
    contents: List[str], class_name: str, function: str
) -> List[str]:
    """Naive function implementation removal.

    :param contents: List of code strings
    :type contents: List[str]
    :param class_name: Name of class from which to remove the function
    :type class_name: str
    :param function: Name of the function to remove
    :type function: str
    :return: List of code strings without the function implementation
    :rtype: List[str]
    """
    in_class = False
    class_indent_level = 0
    in_function = False
    function_indent_level = 0
    final_contents = []
    for line in contents:
        if line.strip() == "":
            # Blank line. Continue.
            if not in_function:
                final_contents.append(line)
            continue
        curr_ident_level = get_indentation_level(line)
        if f"class {class_name}(" in line:
            in_class = True
            class_indent_level = curr_ident_level
        elif in_class and curr_ident_level <= class_indent_level:
            in_class = False
            in_function = False
        if in_class:
            if f"def {function}" in line:
                in_function = True
                function_indent_level = curr_ident_level
            elif in_function and curr_ident_level <= function_indent_level:
                in_function = False
            if in_function:
                continue
        final_contents.append(line)
    return final_contents


def add_libgap_import(contents: List[str], function: str) -> List[str]:
    """Adds a libgap import inside a function, after the docstring.

    :param contents: List of code strings
    :type contents: List[str]
    :param function: Function name
    :type function: str
    :return: Modified code strings
    :rtype: List[str]
    """
    import_statement = "from sage_libgap.libgap import libgap\n"
    in_function = False
    function_indent_level = 0
    in_docstring = False
    final_contents = []
    for line in contents:
        if line.strip() == "":
            # Blank line. Continue.
            final_contents.append(line)
            continue
        curr_ident_level = get_indentation_level(line)
        if f"def {function}" in line:
            in_function = True
            function_indent_level = curr_ident_level
        elif in_function and curr_ident_level <= function_indent_level:
            in_function = False
            in_docstring = False
        if in_function:
            if '"""' in line and not in_docstring:
                in_docstring = True
                docstring_indent_level = curr_ident_level
            elif '"""' in line and in_docstring:
                in_docstring = False
                final_contents.append(line)
                final_contents.append(" " * docstring_indent_level + import_statement)
                continue
        final_contents.append(line)
    return final_contents


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "sage_repo_path",
        help="path to sage repository",
    )
    args = parser.parse_args()

    script_folder = pathlib.Path(__file__).parent
    pkg_folder = script_folder.parent
    bootstrap_folder = pkg_folder.joinpath("bootstrap")
    src_folder = pkg_folder.joinpath("src")
    out_folder = src_folder.joinpath("sage_libgap")
    tests_folder = pkg_folder.joinpath("tests")

    # Create output folder
    if not out_folder.exists():
        out_folder.mkdir(parents=True)

    # Pre-fill with the bootstrap files
    if not bootstrap_folder.exists():
        raise FileNotFoundError('Folder "bootstrap" not found.')
    shutil.copytree(bootstrap_folder, out_folder, dirs_exist_ok=True)

    # Extract original sage files
    sage_libgap_path = pathlib.Path(args.sage_repo_path)

    for file_name, dest_folder_name in SAGE_FILES_TO_COPY.items():
        dest_folder = out_folder.joinpath(dest_folder_name)
        if not dest_folder.exists():
            dest_folder.mkdir(parents=True)
            dest_folder.joinpath("__init__.py").touch()

        orig = sage_libgap_path.joinpath(file_name)
        if orig.is_dir():
            shutil.copytree(orig, dest_folder, dirs_exist_ok=True)
            if dest_folder.joinpath("__init__.py").exists():
                parent = dest_folder.parent
            else:
                parent = dest_folder
            while not parent.joinpath("__init__.py").exists():
                parent.joinpath("__init__.py").touch()
                parent = parent.parent
        else:
            shutil.copy(orig, dest_folder)

    for file in sage_libgap_path.joinpath("src", "sage", "libs", "gap").glob("*"):
        shutil.copy(file, out_folder)

    # Patch the files
    for file in out_folder.glob("**/*"):
        if file.is_dir():
            continue

        # Edit the import statements
        with open(file) as f:
            file_contents = f.read()
        for original_namespace, new_namespace in [
            ["sage.libs.gap", "sage_libgap"],
            ["sage.arith", "sage_libgap.arith"],
            ["sage.cpython", "sage_libgap.cpython"],
            ["sage.env", "sage_libgap.env"],
            ["sage.interfaces", "sage_libgap.interfaces"],
            ["sage.libs.gmp", "sage_libgap.libs.gmp"],
            ["sage.misc", "sage_libgap.misc"],
            ["sage.rings", "sage_libgap.rings"],
            ["sage.structure", "sage_libgap.structure"],
        ]:
            while original_namespace in file_contents:
                file_contents = file_contents.replace(original_namespace, new_namespace)

        # Apply patches
        if file.name in PATCHES:
            file_patches = PATCHES[file.name]
            for original, replacement in file_patches.items():
                while original in file_contents:
                    file_contents = file_contents.replace(original, replacement)

        # Remove function implementations
        if file.name in FUNCTIONS_TO_REMOVE:
            functions_to_remove = FUNCTIONS_TO_REMOVE[file.name]
            code_listing = file_contents.split("\n")
            for class_name, function in functions_to_remove:
                code_listing = remove_function_implementation(
                    code_listing, class_name, function
                )
            file_contents = "\n".join(code_listing)

        # Add libgap import where it is missing
        if file.name in MISSING_LIBGAP_IMPORT:
            functions_to_process = MISSING_LIBGAP_IMPORT[file.name]
            code_listing = file_contents.split("\n")
            for function in functions_to_process:
                code_listing = add_libgap_import(code_listing, function)
            file_contents = "\n".join(code_listing)

        # Write file contents, plus license headers
        with open(file, "w") as f:
            # Skip adding license headers to the bootstrapped files
            if (
                (
                    "#     Copyright (C) 2024 LaiTeP and contributors\n"
                    not in file_contents
                )
                and "#       Copyright (C) 2024 LaiTeP and contributors\n"
                not in file_contents
            ):
                if file.name.endswith(".h"):
                    f.write(AUTOGEN_TEXT_C)
                else:
                    f.write(AUTOGEN_TEXT_PY)
            f.write(file_contents)

    # Move the tests into the `test` folder
    for test_file in out_folder.glob("test*"):
        shutil.move(test_file, tests_folder.joinpath(test_file.name))
